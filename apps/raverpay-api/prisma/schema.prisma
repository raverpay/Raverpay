generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                     String                   @id @default(uuid())
  email                  String                   @unique
  phone                  String                   @unique
  password               String
  firstName              String
  lastName               String
  role                   UserRole                 @default(USER)
  status                 UserStatus               @default(PENDING_VERIFICATION)
  kycTier                KYCTier                  @default(TIER_0)
  avatar                 String?
  dateOfBirth            DateTime?
  gender                 Gender?
  address                String?
  city                   String?
  state                  String?
  country                String                   @default("Nigeria")
  bvn                    String?                  @unique
  bvnVerified            Boolean                  @default(false)
  nin                    String?                  @unique
  ninVerified            Boolean                  @default(false)
  pin                    String?
  pinSetAt               DateTime?
  twoFactorEnabled       Boolean                  @default(false)
  twoFactorSecret        String?
  passwordResetAt        DateTime?                @db.Timestamp(6)
  lastPasswordChange     DateTime?                @db.Timestamp(6)
  emailVerified          Boolean                  @default(false)
  emailVerifiedAt        DateTime?
  phoneVerified          Boolean                  @default(false)
  phoneVerifiedAt        DateTime?
  lastLoginAt            DateTime?
  createdAt              DateTime                 @default(now())
  updatedAt              DateTime                 @updatedAt
  paystackCustomerCode   String?                  @unique
  deletionRequested      Boolean                  @default(false)
  deletionRequestedAt    DateTime?
  profileEditedOnce      Boolean                  @default(false)
  profileEditedAt        DateTime?
  expoPushToken          String?
  lastPushTokenUpdate    DateTime?
  deletedAt              DateTime?
  failedLoginAttempts    Int                      @default(0)
  lockedUntil            DateTime?
  lastFailedLoginAt      DateTime?
  lastSuccessfulLoginIp  String?
  lastLoginEmailSentAt   DateTime?
  rateLimitLockCount     Int                      @default(0)
  lastRateLimitLockAt    DateTime?
  rateLimitLockReason    String?
  tag                    String?                  @unique @db.VarChar(255)
  tagSetAt               DateTime?
  tagChangedCount        Int                      @default(0)
  deletionRequests       AccountDeletionRequest[]
  auditLogs              AuditLog[]
  bankAccounts           BankAccount[]
  cannedResponses        CannedResponse[]         @relation("CannedResponseCreator")
  cashbackTransactions   CashbackTransaction[]
  cashbackWallet         CashbackWallet?
  conversations          Conversation[]
  cryptoConversions      CryptoConversion[]
  cryptoOrders           CryptoOrder[]
  cryptoTransactions     CryptoTransaction[]
  devices                Device[]
  giftCardOrders         GiftCardOrder[]
  inboundEmails          InboundEmail[]           @relation("InboundEmails")
  notificationLogs       NotificationLog[]
  notificationPreference NotificationPreference?
  notificationQueue      NotificationQueue[]
  notifications          Notification[]
  receivedTransfers      P2PTransfer[]            @relation("ReceiverTransfers")
  sentTransfers          P2PTransfer[]            @relation("SenderTransfers")
  rateLimitViolations    RateLimitViolation[]
  refreshTokens          RefreshToken[]
  savedRecipients        SavedRecipient[]
  assignedTickets        Ticket[]                 @relation("AssignedTickets")
  tickets                Ticket[]
  transactions           Transaction[]
  venlyUser              VenlyUser?
  virtualAccounts        VirtualAccount[]
  vtuOrders              VTUOrder[]
  wallets                Wallet[]
  circleWallets          CircleWallet[]
  circleTransactions     CircleTransaction[]
  circleCCTPTransfers    CircleCCTPTransfer[]
  circleUsers            CircleUser[]
  modularWallets         CircleModularWallet[]
  passkeyCredentials     PasskeyCredential[]
  sentEmails             OutboundEmail[]          @relation("SentEmails")
  receivedEmails         OutboundEmail[]          @relation("ReceivedEmails")

  @@index([email])
  @@index([phone])
  @@index([status])
  @@index([tag])
  @@index([email], map: "idx_users_email")
  @@index([phone], map: "idx_users_phone")
  @@index([status], map: "idx_users_status")
  @@index([deletedAt])
  @@index([expoPushToken], map: "users_expopushtoken_idx")
  @@index([lastLoginEmailSentAt])
  @@index([profileEditedOnce])
  @@map("users")
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  isRevoked Boolean  @default(false)
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("refresh_tokens")
}

model Device {
  id             String    @id @default(uuid())
  userId         String
  deviceId       String
  deviceName     String
  deviceType     String
  deviceModel    String?
  osVersion      String?
  appVersion     String?
  ipAddress      String
  lastIpAddress  String?
  location       String?
  userAgent      String?
  isActive       Boolean   @default(true)
  isVerified     Boolean   @default(false)
  isTrusted      Boolean   @default(false)
  firstLoginAt   DateTime  @default(now())
  lastLoginAt    DateTime  @default(now())
  lastActivityAt DateTime  @default(now())
  verifiedAt     DateTime?
  deactivatedAt  DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade, map: "devices_userid_fkey")

  @@unique([deviceId], map: "devices_deviceid_key")
  @@index([deviceId], map: "devices_deviceid_idx")
  @@index([isActive], map: "devices_isactive_idx")
  @@index([userId], map: "devices_userid_idx")
  @@map("devices")
}

model Wallet {
  id             String          @id @default(uuid())
  userId         String
  balance        Decimal         @default(0) @db.Decimal(15, 2)
  ledgerBalance  Decimal         @default(0) @db.Decimal(15, 2)
  currency       String          @default("NGN")
  dailySpent     Decimal         @default(0) @db.Decimal(15, 2)
  monthlySpent   Decimal         @default(0) @db.Decimal(15, 2)
  lastResetAt    DateTime        @default(now())
  isLocked       Boolean         @default(false)
  lockedReason   String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  type           WalletType?     @default(NAIRA)
  venlyWalletId  String?
  walletAddress  String?
  cryptoBalances CryptoBalance[]
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type], map: "wallets_userid_type_key")
  @@index([userId])
  @@index([type])
  @@index([walletAddress])
  @@index([venlyWalletId])
  @@map("wallets")
}

model Transaction {
  id               String            @id @default(uuid())
  reference        String            @unique
  userId           String
  type             TransactionType
  status           TransactionStatus @default(PENDING)
  amount           Decimal           @db.Decimal(15, 2)
  fee              Decimal           @default(0) @db.Decimal(15, 2)
  totalAmount      Decimal           @db.Decimal(15, 2)
  balanceBefore    Decimal           @db.Decimal(15, 2)
  balanceAfter     Decimal           @db.Decimal(15, 2)
  currency         String            @default("NGN")
  metadata         Json?
  relatedType      String?
  relatedId        String?
  provider         String?
  providerRef      String?
  providerStatus   String?
  description      String
  narration        String?
  completedAt      DateTime?
  failedAt         DateTime?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  channel          String?
  cashbackRedeemed Decimal           @default(0) @db.Decimal(15, 2)
  user             User              @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([reference])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@index([reference], map: "idx_transactions_reference")
  @@index([userId, createdAt(sort: Desc)], map: "idx_transactions_user_created")
  @@index([userId, status], map: "idx_transactions_user_status")
  @@index([userId, type], map: "idx_transactions_user_type")
  @@index([status, createdAt], map: "transactions_status_createdat_idx")
  @@index([type, createdAt], map: "transactions_type_createdat_idx")
  @@index([userId, createdAt], map: "transactions_userid_createdat_idx")
  @@map("transactions")
}

model DailyTransactionLimit {
  id                String   @id @default(uuid())
  userId            String
  date              DateTime @default(now())
  totalTransferred  Decimal  @default(0) @db.Decimal(15, 2)
  totalWithdrawn    Decimal  @default(0) @db.Decimal(15, 2)
  totalAirtime      Decimal  @default(0) @db.Decimal(15, 2)
  totalData         Decimal  @default(0) @db.Decimal(15, 2)
  totalBillPayments Decimal  @default(0) @db.Decimal(15, 2)
  transferCount     Int      @default(0)
  withdrawalCount   Int      @default(0)
  airtimeCount      Int      @default(0)
  dataCount         Int      @default(0)
  billPaymentCount  Int      @default(0)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  totalDeposits     Decimal  @default(0) @db.Decimal(15, 2)
  depositCount      Int      @default(0)

  @@unique([userId, date], map: "daily_transaction_limits_userid_date_key")
  @@index([date])
  @@index([userId], map: "daily_transaction_limits_userid_idx")
  @@index([totalDeposits], map: "daily_transaction_limits_totaldeposits_idx")
  @@map("daily_transaction_limits")
}

model BankAccount {
  id            String   @id @default(uuid())
  userId        String
  bankName      String
  bankCode      String
  accountNumber String
  accountName   String
  isVerified    Boolean  @default(false)
  isPrimary     Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, accountNumber])
  @@index([userId])
  @@map("bank_accounts")
}

model VirtualAccount {
  id             String    @id @default(uuid())
  userId         String
  provider       String
  bankName       String
  bankCode       String
  accountNumber  String    @unique
  accountName    String
  providerRef    String?
  isActive       Boolean   @default(true)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  creationStatus String?
  retryCount     Int       @default(0)
  lastRetryAt    DateTime?
  failureReason  String?
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([accountNumber])
  @@index([creationStatus], map: "virtual_accounts_creationstatus_idx")
  @@map("virtual_accounts")
}

model VTUOrder {
  id                 String            @id @default(uuid())
  reference          String            @unique
  userId             String
  serviceType        VTUServiceType
  provider           String
  recipient          String
  productCode        String
  productName        String
  amount             Decimal           @db.Decimal(15, 2)
  status             TransactionStatus @default(PENDING)
  providerRef        String?
  providerToken      String?
  providerResponse   Json?
  transactionId      String?
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  completedAt        DateTime?
  cashbackEarned     Decimal           @default(0) @db.Decimal(15, 2)
  cashbackRedeemed   Decimal           @default(0) @db.Decimal(15, 2)
  cashbackPercentage Decimal           @default(0) @db.Decimal(5, 2)
  user               User              @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([reference])
  @@index([status])
  @@index([status], map: "idx_vtu_orders_status")
  @@index([userId, createdAt(sort: Desc)], map: "idx_vtu_orders_user_created")
  @@index([createdAt], map: "vtu_orders_createdat_idx")
  @@index([status, createdAt], map: "vtu_orders_status_createdat_idx")
  @@index([userId, createdAt], map: "vtu_orders_userid_createdat_idx")
  @@map("vtu_orders")
}

model GiftCardOrder {
  id            String            @id @default(uuid())
  reference     String            @unique
  userId        String
  type          GiftCardType
  brand         String
  country       String
  cardNumber    String?
  cardPin       String?
  cardImages    Json?
  faceValue     Decimal           @db.Decimal(15, 2)
  rate          Decimal           @db.Decimal(5, 2)
  amount        Decimal           @db.Decimal(15, 2)
  status        TransactionStatus @default(PENDING)
  reviewedBy    String?
  reviewedAt    DateTime?
  reviewNotes   String?
  transactionId String?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  completedAt   DateTime?
  user          User              @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([reference])
  @@index([status])
  @@index([createdAt], map: "giftcard_orders_createdat_idx")
  @@index([status, createdAt], map: "giftcard_orders_status_createdat_idx")
  @@index([userId, createdAt], map: "giftcard_orders_userid_createdat_idx")
  @@map("giftcard_orders")
}

model CryptoOrder {
  id            String            @id @default(uuid())
  reference     String            @unique
  userId        String
  type          CryptoOrderType
  asset         String
  network       String
  cryptoAmount  Decimal           @db.Decimal(18, 8)
  nairaAmount   Decimal           @db.Decimal(15, 2)
  rate          Decimal           @db.Decimal(15, 2)
  walletAddress String?
  txHash        String?
  status        TransactionStatus @default(PENDING)
  provider      String?
  providerRef   String?
  transactionId String?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  completedAt   DateTime?
  user          User              @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([reference])
  @@index([status])
  @@index([createdAt], map: "crypto_orders_createdat_idx")
  @@index([status, createdAt], map: "crypto_orders_status_createdat_idx")
  @@index([userId, createdAt], map: "crypto_orders_userid_createdat_idx")
  @@map("crypto_orders")
}

model Notification {
  id             String            @id @default(uuid())
  userId         String
  type           NotificationType
  title          String
  message        String
  data           Json?
  isRead         Boolean           @default(false)
  readAt         DateTime?
  createdAt      DateTime          @default(now())
  eventType      String?
  category       String            @default("SYSTEM")
  channels       String[]          @default(["in-app"])
  deliveryStatus Json?
  templateId     String?
  variables      Json?
  updatedAt      DateTime          @default(now()) @updatedAt
  expiresAt      DateTime?
  logs           NotificationLog[]
  user           User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([category])
  @@index([eventType], map: "notifications_eventtype_idx")
  @@index([userId, createdAt], map: "notifications_userid_createdat_idx")
  @@index([userId, isRead, createdAt], map: "notifications_userid_isread_createdat_idx")
  @@map("notifications")
}

model NotificationPreference {
  id                  String                 @id(map: "NotificationPreference_pkey") @default(uuid())
  userId              String                 @unique(map: "NotificationPreference_userId_key")
  emailEnabled        Boolean                @default(true)
  smsEnabled          Boolean                @default(true)
  pushEnabled         Boolean                @default(true)
  inAppEnabled        Boolean                @default(true)
  transactionEmails   Boolean                @default(true)
  transactionSms      Boolean                @default(true)
  transactionPush     Boolean                @default(true)
  securityEmails      Boolean                @default(true)
  securitySms         Boolean                @default(true)
  securityPush        Boolean                @default(true)
  kycEmails           Boolean                @default(true)
  kycSms              Boolean                @default(true)
  kycPush             Boolean                @default(true)
  promotionalEmails   Boolean                @default(false)
  promotionalSms      Boolean                @default(false)
  promotionalPush     Boolean                @default(false)
  emailFrequency      String                 @default("IMMEDIATE")
  smsFrequency        String                 @default("IMMEDIATE")
  quietHoursEnabled   Boolean                @default(false)
  quietHoursStart     String?
  quietHoursEnd       String?
  timeZone            String                 @default("Africa/Lagos")
  optOutCategories    String[]               @default([])
  createdAt           DateTime               @default(now())
  updatedAt           DateTime               @updatedAt
  pushFrequency       NotificationFrequency? @default(IMMEDIATE)
  oneSignalPlayerId   String?
  oneSignalExternalId String?
  lastPushTokenUpdate DateTime?
  user                User                   @relation(fields: [userId], references: [id], onDelete: Cascade, map: "NotificationPreference_userId_fkey")

  @@index([oneSignalPlayerId])
  @@map("notification_preferences")
}

model NotificationLog {
  id                String       @id(map: "NotificationLog_pkey") @default(uuid())
  notificationId    String
  userId            String
  channel           String
  status            String       @default("PENDING")
  sentAt            DateTime?
  deliveredAt       DateTime?
  failureReason     String?
  retryCount        Int          @default(0)
  lastRetryAt       DateTime?
  openedAt          DateTime?
  clickedAt         DateTime?
  clickUrl          String?
  provider          String?
  providerMessageId String?
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  notification      Notification @relation(fields: [notificationId], references: [id], onDelete: Cascade, map: "NotificationLog_notificationId_fkey")
  user              User         @relation(fields: [userId], references: [id], onDelete: Cascade, map: "NotificationLog_userId_fkey")

  @@index([channel], map: "NotificationLog_channel_idx")
  @@index([notificationId], map: "NotificationLog_notificationId_idx")
  @@index([status], map: "NotificationLog_status_idx")
  @@index([userId], map: "NotificationLog_userId_idx")
  @@map("notification_logs")
}

model NotificationTemplate {
  id           String   @id(map: "NotificationTemplate_pkey") @default(uuid())
  name         String   @unique(map: "NotificationTemplate_name_key")
  eventType    String
  channel      String
  subject      String?
  bodyTemplate String
  variables    String[]
  isActive     Boolean  @default(true)
  version      Int      @default(1)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("notification_templates")
}

model NotificationQueue {
  id           String    @id(map: "NotificationQueue_pkey") @default(uuid())
  userId       String
  channel      String
  eventType    String
  templateId   String?
  variables    Json?
  status       String    @default("QUEUED")
  priority     Int       @default(0)
  retryCount   Int       @default(0)
  maxRetries   Int       @default(3)
  nextRetryAt  DateTime?
  lastError    String?
  scheduledFor DateTime?
  sentAt       DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade, map: "NotificationQueue_userId_fkey")

  @@index([userId])
  @@index([status])
  @@index([channel])
  @@index([scheduledFor])
  @@index([priority])
  @@index([scheduledFor], map: "NotificationQueue_scheduledFor_idx")
  @@index([status], map: "NotificationQueue_status_idx")
  @@index([userId], map: "NotificationQueue_userId_idx")
  @@map("notification_queue")
}

model AuditLog {
  id            String         @id @default(uuid())
  userId        String?
  action        String
  resource      String
  resourceId    String?
  ipAddress     String?
  userAgent     String?
  metadata      Json?
  createdAt     DateTime       @default(now())
  
  // Enhanced fields
  actorType     ActorType?     @default(USER)
  severity      AuditSeverity? @default(LOW)
  status        AuditStatus?   @default(SUCCESS)
  errorMessage  String?        @db.Text
  executionTime Int?
  deviceId      String?
  location      String?
  oldValue      Json?
  newValue      Json?
  
  user          User?          @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@index([actorType])
  @@index([severity])
  @@index([status])
  @@index([action, createdAt], map: "audit_logs_action_createdat_idx")
  @@index([resource, resourceId], map: "audit_logs_resource_resourceid_idx")
  @@index([userId, createdAt], map: "audit_logs_userid_createdat_idx")
  @@index([userId, createdAt(sort: Desc)], map: "idx_audit_logs_user")
  @@index([severity, createdAt])
  @@index([status, createdAt])
  @@map("audit_logs")
}

model SavedRecipient {
  id            String         @id @default(uuid())
  userId        String
  serviceType   VTUServiceType
  provider      String
  recipient     String
  recipientName String?
  lastUsedAt    DateTime       @default(now())
  usageCount    Int            @default(1)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade, map: "saved_recipients_userid_fkey")

  @@unique([userId, serviceType, recipient], map: "saved_recipients_userid_servicetype_recipient_key")
  @@index([lastUsedAt], map: "saved_recipients_lastusedat_idx")
  @@index([userId], map: "saved_recipients_userid_idx")
  @@index([userId, serviceType], map: "saved_recipients_userid_servicetype_idx")
  @@map("saved_recipients")
}

model AccountDeletionRequest {
  id               String                @id @default(uuid())
  userId           String
  reason           String
  customReason     String?
  passwordVerified Boolean               @default(true)
  status           DeletionRequestStatus @default(PENDING)
  reviewedBy       String?
  reviewedAt       DateTime?
  reviewNotes      String?
  rejectionReason  String?
  requestedAt      DateTime              @default(now())
  scheduledFor     DateTime?
  deletedAt        DateTime?
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @default(now()) @updatedAt
  user             User                  @relation(fields: [userId], references: [id], onDelete: Cascade, map: "account_deletion_requests_userid_fkey")

  @@index([userId])
  @@index([status])
  @@index([requestedAt])
  @@map("account_deletion_requests")
}

model SystemConfig {
  id        String   @id @default(uuid())
  key       String   @unique
  value     Json
  updatedBy String?
  updatedAt DateTime @updatedAt

  @@map("system_config")
}

model AppRatingConfig {
  id                      String   @id @default(uuid())
  enabled                 Boolean  @default(true)
  promptFrequencyDays     Int      @default(30)
  minTransactionsRequired Int      @default(3)
  minUsageDaysRequired    Int      @default(7)
  promptTitle             String   @default("Enjoying RaverPay?")
  promptMessage           String   @default("Rate us on the app store! Your feedback helps us improve.")
  iosAppStoreUrl          String   @default("")
  androidPlayStoreUrl     String   @default("")
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  @@map("app_rating_config")
}

model Conversation {
  id                 String             @id @default(uuid())
  userId             String
  status             ConversationStatus @default(OPEN)
  category           String?
  lastMessagePreview String?
  unreadCount        Int                @default(0)
  transactionId      String?
  transactionType    String?
  transactionContext Json?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  user               User               @relation(fields: [userId], references: [id], onDelete: Cascade, map: "conversations_userid_fkey")
  inboundEmail       InboundEmail?      @relation("EmailConversations")
  messages           Message[]
  ticket             Ticket?
  outboundEmails     OutboundEmail[]    @relation("ConversationEmails")

  @@index([status])
  @@index([createdAt], map: "conversations_createdat_idx")
  @@index([userId], map: "conversations_userid_idx")
  @@index([userId, status], map: "conversations_userid_status_idx")
  @@map("conversations")
}

model Message {
  id             String       @id @default(uuid())
  conversationId String
  senderType     SenderType
  senderId       String?
  content        String
  attachments    Json?
  isRead         Boolean      @default(false)
  metadata       Json?
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade, map: "messages_conversationid_fkey")

  @@index([conversationId, createdAt], map: "messages_conversationid_createdat_idx")
  @@index([conversationId], map: "messages_conversationid_idx")
  @@index([createdAt], map: "messages_createdat_idx")
  @@map("messages")
}

model Ticket {
  id              String         @id @default(uuid())
  ticketNumber    Int            @unique(map: "tickets_ticketnumber_key") @default(autoincrement())
  conversationId  String         @unique(map: "tickets_conversationid_key")
  userId          String
  category        String
  title           String
  status          TicketStatus   @default(OPEN)
  priority        TicketPriority @default(MEDIUM)
  assignedAgentId String?
  rating          Int?
  ratingComment   String?
  resolvedAt      DateTime?
  closedAt        DateTime?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  inboundEmail    InboundEmail?  @relation("EmailTickets")
  assignedAgent   User?          @relation("AssignedTickets", fields: [assignedAgentId], references: [id], map: "tickets_assignedagentid_fkey")
  conversation    Conversation   @relation(fields: [conversationId], references: [id], onDelete: Cascade, map: "tickets_conversationid_fkey")
  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade, map: "tickets_userid_fkey")

  @@index([status])
  @@index([priority])
  @@index([status, priority])
  @@index([assignedAgentId], map: "tickets_assignedagentid_idx")
  @@index([createdAt], map: "tickets_createdat_idx")
  @@index([status, createdAt], map: "tickets_status_createdat_idx")
  @@index([ticketNumber], map: "tickets_ticketnumber_idx")
  @@index([userId], map: "tickets_userid_idx")
  @@map("tickets")
}

model InboundEmail {
  id              String        @id @default(uuid())
  emailId         String        @unique
  messageId       String?
  from            String
  fromName        String?
  to              String
  cc              String[]      @default([])
  bcc             String[]      @default([])
  subject         String
  textBody        String?
  htmlBody        String?
  targetRole      UserRole?
  targetEmail     String
  ticketId        String?       @unique
  conversationId  String?       @unique
  userId          String?
  attachments     Json?
  replies         Json?
  isProcessed     Boolean       @default(false)
  processedAt     DateTime?
  processingError String?
  receivedAt      DateTime      @default(now())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  conversation    Conversation? @relation("EmailConversations", fields: [conversationId], references: [id], map: "inbound_emails_conversationid_fkey")
  ticket          Ticket?       @relation("EmailTickets", fields: [ticketId], references: [id], map: "inbound_emails_ticketid_fkey")
  user            User?         @relation("InboundEmails", fields: [userId], references: [id], map: "inbound_emails_userid_fkey")
  outboundEmails  OutboundEmail[] @relation("EmailReplies")

  @@index([conversationId], map: "inbound_emails_conversationid_idx")
  @@index([isProcessed], map: "inbound_emails_isprocessed_idx")
  @@index([receivedAt], map: "inbound_emails_receivedat_idx")
  @@index([targetEmail], map: "inbound_emails_targetemail_idx")
  @@index([targetRole], map: "inbound_emails_targetrole_idx")
  @@index([ticketId], map: "inbound_emails_ticketid_idx")
  @@index([userId], map: "inbound_emails_userid_idx")
  @@map("inbound_emails")
}

model OutboundEmail {
  id             String        @id @default(uuid())
  resendEmailId  String?       @unique
  
  // Sender info (admin who sent it)
  sentBy         String
  fromEmail      String
  
  // Recipient info
  to             String
  cc             String[]      @default([])
  bcc            String[]      @default([])
  
  // Content
  subject        String
  content        String        // HTML content
  attachments    Json?         // Array of attachment metadata
  
  // Context
  inReplyTo      String?       // If replying to an InboundEmail
  inboundEmailId String?
  conversationId String?
  userId         String?       // Recipient user ID (if they're a registered user)
  
  // Status tracking
  status         String        @default("SENT") // SENT, DELIVERED, FAILED, BOUNCED, OPENED, CLICKED
  deliveredAt    DateTime?
  openedAt       DateTime?
  clickedAt      DateTime?
  failureReason  String?
  
  // Metadata
  metadata       Json?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  
  // Relations
  sender         User          @relation("SentEmails", fields: [sentBy], references: [id], onDelete: Cascade, map: "outbound_emails_sentby_fkey")
  user           User?         @relation("ReceivedEmails", fields: [userId], references: [id], onDelete: SetNull, map: "outbound_emails_userid_fkey")
  inboundEmail   InboundEmail? @relation("EmailReplies", fields: [inboundEmailId], references: [id], onDelete: SetNull, map: "outbound_emails_inboundemailid_fkey")
  conversation   Conversation? @relation("ConversationEmails", fields: [conversationId], references: [id], onDelete: SetNull, map: "outbound_emails_conversationid_fkey")
  
  @@index([sentBy], map: "outbound_emails_sentby_idx")
  @@index([fromEmail], map: "outbound_emails_fromemail_idx")
  @@index([to], map: "outbound_emails_to_idx")
  @@index([inboundEmailId], map: "outbound_emails_inboundemailid_idx")
  @@index([conversationId], map: "outbound_emails_conversationid_idx")
  @@index([userId], map: "outbound_emails_userid_idx")
  @@index([status], map: "outbound_emails_status_idx")
  @@index([createdAt], map: "outbound_emails_createdat_idx")
  @@index([sentBy, createdAt], map: "outbound_emails_sentby_createdat_idx")
  @@map("outbound_emails")
}

model EmailRouting {
  id               String          @id @default(uuid())
  emailAddress     String          @unique
  targetRole       UserRole
  autoCreateTicket Boolean         @default(false)
  defaultPriority  TicketPriority?
  defaultCategory  String?
  isActive         Boolean         @default(true)
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  @@index([isActive], map: "email_routing_isactive_idx")
  @@index([targetRole], map: "email_routing_targetrole_idx")
  @@map("email_routing")
}

model HelpCollection {
  id          String        @id @default(uuid())
  title       String
  description String
  icon        String?
  order       Int           @default(0)
  isActive    Boolean       @default(true)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  articles    HelpArticle[]

  @@index([order])
  @@index([isActive], map: "help_collections_isactive_idx")
  @@map("help_collections")
}

model HelpArticle {
  id             String         @id @default(uuid())
  collectionId   String
  title          String
  content        String
  slug           String         @unique
  order          Int            @default(0)
  viewCount      Int            @default(0)
  helpfulCount   Int            @default(0)
  unhelpfulCount Int            @default(0)
  isActive       Boolean        @default(true)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  collection     HelpCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade, map: "help_articles_collectionid_fkey")

  @@index([order])
  @@index([slug])
  @@index([collectionId], map: "help_articles_collectionid_idx")
  @@index([isActive], map: "help_articles_isactive_idx")
  @@map("help_articles")
}

model CannedResponse {
  id          String   @id @default(uuid())
  title       String
  content     String
  category    String?
  shortcut    String?
  isActive    Boolean  @default(true)
  usageCount  Int      @default(0)
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   User     @relation("CannedResponseCreator", fields: [createdById], references: [id], onDelete: Cascade, map: "canned_responses_createdbyid_fkey")

  @@index([category])
  @@index([shortcut])
  @@index([isActive], map: "canned_responses_isactive_idx")
  @@map("canned_responses")
}

model CashbackConfig {
  id          String   @id @default(uuid())
  serviceType String
  percentage  Decimal  @db.Decimal(5, 2)
  isActive    Boolean  @default(true)
  provider    String?
  minAmount   Decimal  @default(0) @db.Decimal(15, 2)
  maxCashback Decimal? @db.Decimal(15, 2)
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([serviceType, provider], map: "cashback_config_servicetype_provider_key")
  @@index([isActive], map: "cashback_config_isactive_idx")
  @@index([serviceType], map: "cashback_config_servicetype_idx")
  @@map("cashback_config")
}

model CashbackWallet {
  id               String   @id @default(uuid())
  userId           String   @unique(map: "cashback_wallets_userid_key")
  totalEarned      Decimal  @default(0) @db.Decimal(15, 2)
  availableBalance Decimal  @default(0) @db.Decimal(15, 2)
  totalRedeemed    Decimal  @default(0) @db.Decimal(15, 2)
  isActive         Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade, map: "cashback_wallets_userid_fkey")

  @@index([userId], map: "cashback_wallets_userid_idx")
  @@map("cashback_wallets")
}

model CashbackTransaction {
  id              String                  @id @default(uuid())
  userId          String
  type            CashbackTransactionType
  amount          Decimal                 @db.Decimal(15, 2)
  balanceBefore   Decimal                 @db.Decimal(15, 2)
  balanceAfter    Decimal                 @db.Decimal(15, 2)
  sourceReference String?
  description     String
  metadata        Json?
  createdAt       DateTime                @default(now())
  user            User                    @relation(fields: [userId], references: [id], onDelete: Cascade, map: "cashback_transactions_userid_fkey")

  @@index([type])
  @@index([createdAt], map: "cashback_transactions_createdat_idx")
  @@index([sourceReference], map: "cashback_transactions_sourcereference_idx")
  @@index([userId, createdAt], map: "cashback_transactions_userid_createdat_idx")
  @@index([userId], map: "cashback_transactions_userid_idx")
  @@map("cashback_transactions")
}

model WithdrawalConfig {
  id            String            @id @default(uuid())
  feeType       WithdrawalFeeType @default(PERCENTAGE)
  feeValue      Decimal           @db.Decimal(15, 2)
  minFee        Decimal           @default(0) @db.Decimal(15, 2)
  maxFee        Decimal?          @db.Decimal(15, 2)
  tierLevel     KYCTier?          @unique(map: "withdrawal_config_tierlevel_key")
  minWithdrawal Decimal           @default(100) @db.Decimal(15, 2)
  maxWithdrawal Decimal           @default(50000) @db.Decimal(15, 2)
  isActive      Boolean           @default(true)
  description   String?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  @@index([isActive], map: "withdrawal_config_isactive_idx")
  @@map("withdrawal_config")
}

model CryptoBalance {
  id            String   @id @default(uuid())
  walletId      String
  tokenSymbol   String
  tokenAddress  String?
  tokenDecimals Int      @default(18)
  balance       Decimal  @db.Decimal(36, 18)
  rawBalance    String
  usdPrice      Decimal? @db.Decimal(18, 8)
  usdValue      Decimal? @db.Decimal(18, 2)
  lastUpdated   DateTime @default(now())
  wallet        Wallet   @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@unique([walletId, tokenSymbol])
  @@index([walletId])
  @@index([tokenSymbol])
  @@map("crypto_balances")
}

model CryptoTransaction {
  id                 String                  @id @default(uuid())
  reference          String                  @unique
  transactionHash    String                  @unique
  userId             String
  walletId           String
  type               CryptoTransactionType
  direction          TransactionDirection
  fromAddress        String
  toAddress          String
  tokenSymbol        String
  tokenAddress       String?
  tokenDecimals      Int                     @default(6)
  amount             Decimal                 @db.Decimal(36, 18)
  rawAmount          String
  usdValue           Decimal                 @db.Decimal(18, 2)
  gasFee             Decimal?                @db.Decimal(10, 6)
  gasFeeUsd          Decimal?                @db.Decimal(10, 2)
  network            String                  @default("MATIC")
  blockNumber        Int?
  blockHash          String?
  confirmations      Int                     @default(0)
  hasReachedFinality Boolean                 @default(false)
  nonce              Int?
  status             CryptoTransactionStatus @default(PENDING)
  failureReason      String?
  memo               String?
  submittedAt        DateTime                @default(now())
  confirmedAt        DateTime?
  createdAt          DateTime                @default(now())
  updatedAt          DateTime                @updatedAt
  user               User                    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([walletId])
  @@index([transactionHash])
  @@index([status])
  @@index([type])
  @@index([direction])
  @@index([submittedAt])
  @@index([status, submittedAt])
  @@map("crypto_transactions")
}

model CryptoConversion {
  id                  String           @id @default(uuid())
  reference           String           @unique
  userId              String
  tokenSymbol         String
  cryptoAmount        Decimal          @db.Decimal(36, 18)
  usdValue            Decimal          @db.Decimal(18, 2)
  nairaAmount         Decimal          @db.Decimal(18, 2)
  exchangeRate        Decimal          @db.Decimal(10, 2)
  feePercent          Decimal          @db.Decimal(5, 2)
  feeAmount           Decimal          @db.Decimal(18, 2)
  netNaira            Decimal          @db.Decimal(18, 2)
  status              ConversionStatus @default(PENDING)
  requiresApproval    Boolean          @default(false)
  approvedBy          String?
  approvedAt          DateTime?
  rejectionReason     String?
  cryptoTransactionId String?
  nairaTransactionId  String?
  requestedAt         DateTime         @default(now())
  completedAt         DateTime?
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt
  user                User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([requestedAt])
  @@map("crypto_conversions")
}

model ExchangeRate {
  id                 String    @id @default(uuid())
  fromCurrency       String
  toCurrency         String
  rate               Decimal   @db.Decimal(10, 2)
  platformFeePercent Decimal   @db.Decimal(5, 2)
  isActive           Boolean   @default(true)
  setBy              String
  setAt              DateTime  @default(now())
  expiresAt          DateTime?
  source             String?
  notes              String?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  @@index([fromCurrency, toCurrency, isActive])
  @@index([isActive])
  @@map("exchange_rates")
}

model CryptoPrice {
  id        String   @id @default(uuid())
  symbol    String
  usdPrice  Decimal  @db.Decimal(18, 8)
  source    String   @default("coingecko")
  fetchedAt DateTime @default(now())
  createdAt DateTime @default(now())

  @@unique([symbol, fetchedAt])
  @@index([symbol])
  @@index([fetchedAt])
  @@map("crypto_prices")
}

model CryptoWebhookLog {
  id              String    @id @default(uuid())
  eventType       String
  payload         Json
  processed       Boolean   @default(false)
  processedAt     DateTime?
  error           String?
  transactionHash String?
  fromAddress     String?
  toAddress       String?
  amount          Decimal?  @db.Decimal(18, 8)
  tokenSymbol     String?
  receivedAt      DateTime  @default(now())

  @@index([eventType])
  @@index([transactionHash])
  @@index([processed])
  @@index([receivedAt])
  @@map("crypto_webhook_logs")
}

model VenlyUser {
  id                   String    @id @default(uuid())
  userId               String    @unique
  venlyUserId          String    @unique
  venlySigningMethodId String?
  venlyReference       String
  encryptedPin         String
  pinSetAt             DateTime?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([venlyUserId])
  @@index([userId])
  @@map("venly_users")
}

// ============================================
// CIRCLE INTEGRATION MODELS
// ============================================

model CircleUser {
  id                      String                   @id @default(uuid())
  userId                  String                   @map("user_id")
  circleUserId            String                   @unique @map("circle_user_id")
  authMethod              String                   @map("auth_method") // EMAIL | PIN | SOCIAL
  email                   String?
  status                  String                   @default("ENABLED") // ENABLED | DISABLED
  pinStatus               String?                  @map("pin_status") // ENABLED | DISABLED
  securityQuestionStatus  String?                  @map("security_question_status") // ENABLED | DISABLED
  createdAt               DateTime                 @default(now()) @map("created_at")
  updatedAt               DateTime                 @updatedAt @map("updated_at")
  user                    User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  wallets                 CircleWallet[]
  securityQuestions       CircleSecurityQuestion[]

  @@index([userId])
  @@index([circleUserId])
  @@index([email])
  @@map("circle_users")
}

model CircleSecurityQuestion {
  id            String     @id @default(uuid())
  circleUserId  String     @map("circle_user_id")
  questionId    String     @map("question_id")
  questionText  String     @map("question_text")
  questionIndex Int        @map("question_index") // 0 or 1 (first or second question)
  createdAt     DateTime   @default(now()) @map("created_at")
  updatedAt     DateTime   @updatedAt @map("updated_at")
  circleUser    CircleUser @relation(fields: [circleUserId], references: [id], onDelete: Cascade)

  @@unique([circleUserId, questionIndex])
  @@index([circleUserId])
  @@map("circle_security_questions")
}

model CircleWalletSet {
  id              String         @id @default(uuid())
  circleWalletSetId String       @unique
  name            String?
  custodyType     String         @default("DEVELOPER")
  isActive        Boolean        @default(true)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  circleWallets   CircleWallet[]

  @@index([circleWalletSetId])
  @@index([isActive])
  @@map("circle_wallet_sets")
}

// BlockchainConfig - Admin-managed blockchain settings
model BlockchainConfig {
  id              String   @id @default(uuid())
  blockchain      String   @unique  // e.g., "BASE-SEPOLIA", "MATIC", "ETH"
  name            String             // e.g., "Base Sepolia", "Polygon", "Ethereum"
  symbol          String             // e.g., "ETH", "MATIC", "POL"
  isEnabled       Boolean  @default(false)  // Admin can toggle
  isTestnet       Boolean  @default(false)
  feeLabel        String?            // e.g., "Free (Testnet)", "Gas Sponsored"
  estimatedCost   String?            // e.g., "$0.00", "~$0.01"
  description     String?
  isRecommended   Boolean  @default(false)
  displayOrder    Int      @default(0)
  isCCTPSupported Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([isEnabled])
  @@index([isTestnet])
  @@index([displayOrder])
  @@map("blockchain_configs")
}

model CircleWallet {
  id               String              @id @default(uuid())
  userId           String
  circleWalletId   String              @unique
  walletSetId      String
  address          String
  blockchain       String
  accountType      CircleAccountType   @default(SCA)
  state            CircleWalletState   @default(LIVE)
  name             String?
  refId            String?
  custodyType      String              @default("DEVELOPER") // DEVELOPER | USER
  circleUserId     String?             // Circle user ID for user-controlled wallets
  scaCore          String?
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt
  user             User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  walletSet        CircleWalletSet     @relation(fields: [walletSetId], references: [id], onDelete: Cascade)
  circleUser       CircleUser?         @relation(fields: [circleUserId], references: [id])
  circleTransactions CircleTransaction[]
  paymasterUserOps PaymasterUserOperation[]

  @@unique([userId, blockchain, custodyType])
  @@index([circleWalletId])
  @@index([userId])
  @@index([walletSetId])
  @@index([address])
  @@index([blockchain])
  @@index([state])
  @@index([custodyType])
  @@index([circleUserId])
  @@map("circle_wallets")
}

model CircleTransaction {
  id                    String                    @id @default(uuid())
  reference             String                    @unique
  circleTransactionId   String                    @unique
  userId                String
  walletId              String
  type                  CircleTransactionType
  state                 CircleTransactionState    @default(INITIATED)
  sourceAddress         String?
  destinationAddress    String
  tokenId               String?
  tokenAddress          String?
  blockchain            String
  amounts               String[]
  feeLevel              String?
  gasLimit              String?
  gasPrice              String?
  maxFee                String?
  priorityFee           String?
  transactionHash       String?
  blockNumber           Int?
  blockHash             String?
  networkFee            String?
  networkFeeUsd         String?
  refId                 String?
  errorCode             String?
  errorMessage          String?
  errorReason           String?
  firstConfirmDate      DateTime?
  estimatedCompleteDate DateTime?
  completedDate         DateTime?
  cancelledDate         DateTime?
  // Transaction fee fields
  serviceFee            String?                   // Service fee amount in USDC
  feeCollected          Boolean                   @default(false) // Whether fee was successfully collected
  totalAmount           String?                   // Total amount (amount + serviceFee)
  mainTransferId        String?                   // Circle transaction ID for main transfer
  feeTransferId         String?                   // Circle transaction ID for fee transfer
  createdAt             DateTime                  @default(now())
  updatedAt             DateTime                  @updatedAt
  user                  User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  wallet                CircleWallet              @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@index([circleTransactionId])
  @@index([userId])
  @@index([walletId])
  @@index([state])
  @@index([type])
  @@index([transactionHash])
  @@index([createdAt])
  @@index([userId, createdAt(sort: Desc)])
  @@index([feeCollected])
  @@map("circle_transactions")
}

model FeeRetryQueue {
  id                String   @id @default(uuid())
  walletId          String
  collectionWallet  String
  fee               String   // Fee amount in USDC
  mainTransferId    String   // Reference to main transaction
  retryCount        Int      @default(0)
  status            String   @default("PENDING") // PENDING, COMPLETED, FAILED
  lastError         String?
  lastRetryAt       DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([status])
  @@index([createdAt])
  @@index([mainTransferId])
  @@map("fee_retry_queue")
}

model CircleWebhookLog {
  id              String    @id @default(uuid())
  subscriptionId  String?
  notificationId  String?   @unique
  eventType       String
  payload         Json
  signature       String?
  isValid         Boolean   @default(true)
  processed       Boolean   @default(false)
  processedAt     DateTime?
  error           String?
  retryCount      Int       @default(0)
  lastRetryAt     DateTime?
  entityId        String?
  walletId        String?
  transactionId   String?
  receivedAt      DateTime  @default(now())
  createdAt       DateTime  @default(now())

  @@index([eventType])
  @@index([processed])
  @@index([receivedAt])
  @@index([entityId])
  @@index([walletId])
  @@index([transactionId])
  @@map("circle_webhook_logs")
}

model CircleCCTPTransfer {
  id                    String               @id @default(uuid())
  reference             String               @unique
  userId                String
  sourceWalletId        String
  sourceChain           String
  destinationChain      String
  destinationAddress    String
  amount                String
  burnTransactionId     String?
  burnTransactionHash   String?
  attestationHash       String?
  attestationStatus     String?
  mintTransactionId     String?
  mintTransactionHash   String?
  state                 CCTPTransferState    @default(INITIATED)
  transferType          String               @default("STANDARD")
  feeAmount             String?
  errorCode             String?
  errorMessage          String?
  initiatedAt           DateTime             @default(now())
  burnConfirmedAt       DateTime?
  attestationReceivedAt DateTime?
  mintConfirmedAt       DateTime?
  completedAt           DateTime?
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
  user                  User                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([sourceWalletId])
  @@index([state])
  @@index([sourceChain])
  @@index([destinationChain])
  @@index([burnTransactionHash])
  @@index([mintTransactionHash])
  @@index([createdAt])
  @@map("circle_cctp_transfers")
}

model PaymasterUserOperation {
  id                String             @id @default(uuid())
  userOpHash        String             @unique
  sender            String
  walletId          String
  blockchain        String
  transactionHash   String?
  status            String             @default("PENDING")
  estimatedGasUsdc  String
  actualGasUsdc     String?
  permitSignature   String
  paymasterData     String
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  wallet            CircleWallet       @relation(fields: [walletId], references: [id], onDelete: Restrict)
  events            PaymasterEvent[]

  @@index([walletId])
  @@index([status])
  @@index([blockchain])
  @@index([sender])
  @@index([createdAt])
  @@map("paymaster_user_operations")
}

model PaymasterEvent {
  id                  String                   @id @default(uuid())
  userOpHash          String
  token               String
  sender              String
  nativeTokenPrice    String
  actualTokenNeeded   String
  feeTokenAmount      String
  transactionHash     String
  blockNumber         Int
  createdAt           DateTime                 @default(now())
  userOp              PaymasterUserOperation   @relation(fields: [userOpHash], references: [userOpHash], onDelete: Restrict)

  @@index([userOpHash])
  @@index([sender])
  @@index([transactionHash])
  @@index([createdAt])
  @@map("paymaster_events")
}


model P2PTransfer {
  id                    String   @id @default(uuid())
  reference             String   @unique
  senderId              String
  receiverId            String
  amount                Decimal  @db.Decimal(15, 2)
  fee                   Decimal  @default(0) @db.Decimal(15, 2)
  status                String   @default("COMPLETED")
  message               String?  @db.VarChar(200)
  senderTransactionId   String
  receiverTransactionId String
  createdAt             DateTime @default(now())
  receiver              User     @relation("ReceiverTransfers", fields: [receiverId], references: [id], onDelete: Cascade)
  sender                User     @relation("SenderTransfers", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([senderId])
  @@index([receiverId])
  @@index([createdAt])
  @@index([senderId, createdAt])
  @@index([receiverId, createdAt])
  @@map("p2p_transfers")
}

model reserved_tags {
  id        String   @id
  tag       String   @unique
  reason    String?
  createdAt DateTime @default(now())
}

model RateLimitViolation {
  id         String   @id @default(uuid())
  userId     String?
  ip         String
  endpoint   String
  method     String
  userAgent  String?
  country    String?
  city       String?
  limit      Int
  hitCount   Int
  violatedAt DateTime @default(now())
  createdAt  DateTime @default(now())
  user       User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([ip])
  @@index([endpoint])
  @@index([violatedAt])
  @@map("rate_limit_violations")
}

model RateLimitMetrics {
  id          String   @id @default(uuid())
  date        DateTime
  endpoint    String
  totalHits   Int      @default(0)
  violations  Int      @default(0)
  uniqueIPs   Int      @default(0)
  uniqueUsers Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([date, endpoint])
  @@index([date])
  @@index([endpoint])
  @@map("rate_limit_metrics")
}

model IdempotencyKey {
  id          String   @id @default(uuid())
  key         String   @unique
  userId      String?
  endpoint    String
  method      String
  requestHash String
  response    Json?
  status      String   @default("PENDING") // PENDING, COMPLETED, FAILED
  createdAt   DateTime @default(now())
  expiresAt   DateTime

  @@index([key])
  @@index([userId])
  @@index([status])
  @@index([expiresAt])
  @@map("idempotency_keys")
}

enum UserRole {
  USER
  ADMIN
  SUPPORT
  SUPER_ADMIN
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  BANNED
  PENDING_VERIFICATION
  PENDING_DELETION
  DELETED
  LOCKED
}

enum KYCTier {
  TIER_0
  TIER_1
  TIER_2
  TIER_3
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum WalletType {
  NAIRA
  CRYPTO
  USD
}

enum TransactionType {
  DEPOSIT
  WITHDRAWAL
  TRANSFER
  VTU_AIRTIME
  VTU_DATA
  VTU_CABLE
  VTU_ELECTRICITY
  VTU_EDUCATION
  GIFTCARD_BUY
  GIFTCARD_SELL
  CRYPTO_BUY
  CRYPTO_SELL
  REFUND
  FEE
  CRYPTO_DEPOSIT
  CRYPTO_SEND
  CRYPTO_TO_NAIRA
  USD_DEPOSIT
  USD_WITHDRAWAL
  CARD_LOAD
  CARD_PURCHASE
  CRYPTO_TO_USD
}

enum TransactionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REVERSED
}

enum VTUServiceType {
  AIRTIME
  DATA
  CABLE_TV
  ELECTRICITY
  JAMB
  WAEC_REGISTRATION
  WAEC_RESULT
}

enum GiftCardType {
  BUY
  SELL
}

enum CryptoOrderType {
  BUY
  SELL
}

enum NotificationType {
  TRANSACTION
  KYC
  SECURITY
  PROMOTIONAL
  SYSTEM
}

enum NotificationCategory {
  TRANSACTION
  SECURITY
  KYC
  PROMOTIONAL
  SYSTEM
  ACCOUNT
}

enum NotificationFrequency {
  IMMEDIATE
  DAILY
  WEEKLY
  NEVER
}

enum NotificationChannel {
  EMAIL
  SMS
  PUSH
  IN_APP
}

enum NotificationStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
  BOUNCED
}

enum QueueStatus {
  QUEUED
  PROCESSING
  SENT
  FAILED
  CANCELLED
}

enum DeletionRequestStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
  CANCELLED
}

enum ConversationStatus {
  OPEN
  BOT_HANDLING
  AWAITING_AGENT
  AGENT_ASSIGNED
  AWAITING_RATING
  ENDED
}

enum SenderType {
  USER
  BOT
  AGENT
  SYSTEM
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum CashbackTransactionType {
  EARNED
  REDEEMED
  EXPIRED
  REVERSED
}

enum WithdrawalFeeType {
  FLAT
  PERCENTAGE
}

enum CryptoTransactionType {
  RECEIVE
  SEND
  CONVERT
}

enum TransactionDirection {
  INCOMING
  OUTGOING
}

enum CryptoTransactionStatus {
  PENDING
  CONFIRMING
  COMPLETED
  FAILED
}

enum ConversionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REJECTED
}

// ============================================
// CIRCLE INTEGRATION ENUMS
// ============================================

enum CircleAccountType {
  SCA
  EOA
}

enum CircleWalletState {
  LIVE
  FROZEN
}

enum CircleTransactionType {
  TRANSFER
  CONTRACT_EXECUTION
  CCTP_BURN
  CCTP_MINT
}

enum CircleTransactionState {
  INITIATED
  QUEUED
  SENT
  CONFIRMED
  COMPLETE
  FAILED
  CANCELLED
  DENIED
  STUCK
  CLEARED
}

enum CCTPTransferState {
  INITIATED
  BURN_PENDING
  BURN_CONFIRMED
  ATTESTATION_PENDING
  ATTESTATION_RECEIVED
  MINT_PENDING
  MINT_CONFIRMED
  COMPLETED
  FAILED
  CANCELLED
}

// ============================================
// CIRCLE MODULAR WALLETS
// ============================================

model CircleModularWallet {
  id              String   @id @default(uuid())
  userId          String   @map("user_id")
  circleWalletId  String   @unique @map("circle_wallet_id")
  address         String
  blockchain      String
  name            String?
  state           String   @default("LIVE")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([address])
  @@map("circle_modular_wallets")
}

model PasskeyCredential {
  id           String    @id @default(uuid())
  userId       String    @map("user_id")
  credentialId String    @unique @map("credential_id")
  publicKey    String    @map("public_key")
  rpId         String?   @map("rp_id")
  username     String?
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")
  lastUsedAt   DateTime? @map("last_used_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("passkey_credentials")
}

// ============================================
// AUDIT LOG ENUMS
// ============================================

enum ActorType {
  USER
  ADMIN
  SYSTEM
  WEBHOOK
  API
}

enum AuditSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum AuditStatus {
  SUCCESS
  FAILURE
  PENDING
}
